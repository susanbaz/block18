"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sel = exports.Selector = void 0;
const expression_1 = require("./expression");
const combinator_1 = require("./combinator");
const ampersand_1 = require("./ampersand");
const ws_1 = require("./ws");
const node_1 = require("./node");
const nil_1 = require("./nil");
const list_1 = require("./list");
/**
 * @example
 * #id > .class.class
 *
 * Stored as:
 * [Element, Combinator, Element, Element]
 *
 * @todo
 * Push an ampersand at the beginning of selector expressions
 * if there isn't one
 */
class Selector extends expression_1.Expression {
    constructor(value, location) {
        if (node_1.isNodeMap(value)) {
            super(value, location);
            return;
        }
        const values = value.map(v => v.constructor === String ? new combinator_1.Combinator(v) : v);
        super({
            value: values
        }, location);
    }
    eval(context) {
        let selector = this.clone();
        let elements = [...selector.value];
        selector.value = elements;
        const hasAmp = elements.find(el => el instanceof ampersand_1.Ampersand);
        /**
         * Try to evaluate all selectors as if they are prepended by `&`
         */
        if (!hasAmp) {
            if (elements[0] instanceof combinator_1.Combinator) {
                elements.unshift(new ampersand_1.Ampersand());
            }
            else {
                elements.unshift(new ampersand_1.Ampersand(), new combinator_1.Combinator(' '));
            }
        }
        selector = super.eval.call(selector, context);
        const cleanElements = (elements) => {
            for (let i = 0; i < elements.length; i++) {
                let value = elements[0];
                if ((value instanceof Selector &&
                    value.value.length === 0) ||
                    value instanceof nil_1.Nil ||
                    value instanceof combinator_1.Combinator ||
                    value instanceof ws_1.WS) {
                    elements.shift();
                }
                else {
                    break;
                }
            }
        };
        if (selector instanceof list_1.List) {
            selector.value.forEach(sel => cleanElements(sel.value));
        }
        else {
            cleanElements(selector.value);
        }
        if (elements.length === 0) {
            return new nil_1.Nil();
        }
        return selector;
    }
    toCSS(context, out) {
        this.value.forEach(node => node.toCSS(context, out));
    }
    toModule(context, out) {
        out.add(`$J.sel([`, this.location);
        const length = this.value.length - 1;
        this.value.forEach((node, i) => {
            node.toModule(context, out);
            if (i < length) {
                out.add(', ');
            }
        });
        out.add(`])`);
    }
}
exports.Selector = Selector;
Selector.prototype.type = 'Selector';
const sel = (value, location) => new Selector(value, location);
exports.sel = sel;
