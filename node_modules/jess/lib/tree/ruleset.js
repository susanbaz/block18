"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ruleset = exports.Ruleset = void 0;
const node_1 = require("./node");
const js_node_1 = require("./js-node");
const nil_1 = require("./nil");
const declaration_1 = require("./declaration");
const js_expr_1 = require("./js-expr");
const call_1 = require("./call");
const list_1 = require("./list");
/**
 * A set of nodes (usually declarations)
 * Used by Rule and Mixin
 *
 * @example
 * color: black;
 * background-color: white;
 */
class Ruleset extends node_1.Node {
    constructor() {
        super(...arguments);
        this.rootRules = [];
    }
    eval(context) {
        if (!this.evaluated) {
            const rule = this.clone();
            const rules = [];
            this.value.forEach(rule => {
                rule = rule.eval(context);
                if (rule && !(rule instanceof nil_1.Nil)) {
                    if (rule.type === 'Rule' || rule.type === 'AtRule') {
                        this.rootRules.push(rule, ...rule.collectRoots());
                    }
                    else if (rule instanceof Ruleset) {
                        /** Collapse a ruleset into rules */
                        rule.value.forEach(r => {
                            if (r.type === 'Rule' || r.type === 'AtRule') {
                                this.rootRules.push(r);
                            }
                            else {
                                rules.push(r);
                            }
                        });
                    }
                    else {
                        rules.push(rule);
                    }
                }
            });
            rule.value = rules;
            rule.evaluated = true;
            return rule;
        }
        return this;
    }
    /**
     * Return an object representation of a ruleset
     */
    obj() {
        const value = this.value;
        const output = {};
        value.forEach(n => {
            if (n instanceof declaration_1.Declaration) {
                output[n.name.toString()] = `${n.value}${n.important ? ` ${n.important}` : ''}`;
            }
        });
        return output;
    }
    toCSS(context, out) {
        const value = this.value;
        out.add('{\n');
        context.indent++;
        let pre = context.pre;
        value.forEach(v => {
            out.add(pre);
            v.toCSS(context, out);
            out.add('\n');
        });
        context.indent--;
        pre = context.pre;
        out.add(`${pre}}`);
    }
    toModule(context, out) {
        const depth = context.depth;
        context.depth = 2;
        out.add(`$J.ruleset(\n`, this.location);
        context.indent++;
        let pre = context.pre;
        out.add(`${pre}(() => {\n`);
        context.indent++;
        out.add(`  ${pre}const $OUT = []\n`);
        this.value.forEach((node, i) => {
            out.add(`  ${pre}`);
            if (node instanceof js_node_1.JsNode) {
                node.toModule(context, out);
                out.add('\n');
            }
            else if (node instanceof declaration_1.Declaration && context.opts.dynamic) {
                /**
                 * Creates either runtime vars or var() depending on settings
                 */
                const n = node.clone();
                const process = (n) => {
                    if (n instanceof js_expr_1.JsExpr || n instanceof call_1.Call) {
                        if (context.isRuntime) {
                            context.rootRules.push(new declaration_1.Declaration({
                                name: context.getVar(),
                                value: n
                            }));
                            return n;
                        }
                        return new call_1.Call({
                            name: 'var',
                            value: new list_1.List([
                                context.getVar(),
                                n
                            ])
                        });
                    }
                    n.processNodes(process);
                    return n;
                };
                n.processNodes(process);
                if (context.isRuntime) {
                    context.rootRules.forEach(n => {
                        out.add(`$OUT.push(`);
                        n.toModule(context, out);
                        out.add(`)\n`);
                    });
                    context.rootRules = [];
                }
                else {
                    out.add(`$OUT.push(`);
                    n.toModule(context, out);
                    out.add(`)\n`);
                }
            }
            else {
                out.add(`$OUT.push(`);
                node.toModule(context, out);
                out.add(`)\n`);
            }
        });
        out.add(`  ${pre}return $OUT\n${pre}})()`);
        context.indent -= 2;
        pre = context.pre;
        out.add(`\n${pre})`);
        context.depth = depth;
    }
}
exports.Ruleset = Ruleset;
Ruleset.prototype.allowRuleRoot = true;
Ruleset.prototype.type = 'Ruleset';
const ruleset = (value, location) => new Ruleset(value, location);
exports.ruleset = ruleset;
