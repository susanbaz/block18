"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Node = exports.isNodeMap = void 0;
const isNodeMap = (val) => {
    return val
        && typeof val === 'object'
        && val.constructor === Object
        && Object.prototype.hasOwnProperty.call(val, 'value');
};
exports.isNodeMap = isNodeMap;
class Node {
    constructor(value, location, fileInfo) {
        if (value === undefined) {
            throw { message: 'Node requires a value.' };
        }
        let nodes;
        let nodeKeys;
        if (exports.isNodeMap(value)) {
            nodes = value;
            nodeKeys = Object.keys(nodes);
        }
        else {
            nodes = { value };
            nodeKeys = ['value'];
        }
        this._nodeKeys = nodeKeys;
        /** Place all sub-node keys on `this` */
        nodeKeys.forEach(key => {
            const value = nodes[key];
            this[key] = value;
        });
        this.location = location || [];
        this.fileInfo = fileInfo || {};
    }
    /**
     * Mutates node children in place. Used by eval()
     * which first makes a shallow clone before mutating.
     */
    processNodes(func) {
        const keys = this._nodeKeys;
        keys.forEach(key => {
            const nodeVal = this[key];
            if (nodeVal) {
                /** Process Node arrays only */
                if (Array.isArray(nodeVal)) {
                    const out = [];
                    for (let i = 0; i < nodeVal.length; i++) {
                        const node = nodeVal[i];
                        const result = node instanceof Node ? func(node) : node;
                        if (result) {
                            out.push(result);
                        }
                    }
                    this[key] = out;
                }
                else if (nodeVal instanceof Node) {
                    this[key] = func(nodeVal);
                }
            }
        });
    }
    /**
     * Fire a function for each Node in the tree, recursively
     */
    walkNodes(func) {
        const keys = this._nodeKeys;
        keys.forEach(key => {
            const nodeVal = this[key];
            if (nodeVal) {
                /** Process Node arrays only */
                if (Array.isArray(nodeVal)) {
                    for (let i = 0; i < nodeVal.length; i++) {
                        const node = nodeVal[i];
                        if (node instanceof Node) {
                            func(node);
                            node.walkNodes(func);
                        }
                    }
                }
                else if (nodeVal instanceof Node) {
                    func(nodeVal);
                    nodeVal.walkNodes(func);
                }
            }
        });
    }
    collectRoots() {
        const nodes = new Set();
        this.walkNodes(n => {
            if (n.type === 'Ruleset') {
                n.rootRules.forEach(n => {
                    nodes.add(n);
                });
                n.rootRules = [];
            }
        });
        return Array.from(nodes);
    }
    accept(visitor) {
        this.processNodes(n => visitor.visit(n));
    }
    /**
     * Creates a copy of the current node.
     */
    clone() {
        const Clazz = Object.getPrototypeOf(this).constructor;
        const nodeKeys = this._nodeKeys;
        const nodes = {};
        nodeKeys.forEach(key => {
            nodes[key] = this[key];
        });
        const newNode = new Clazz(nodes, this.location, this.fileInfo);
        /**
         * Copy added properties on `this`
         */
        for (let prop in this) {
            if (Object.prototype.hasOwnProperty.call(this, prop) && nodeKeys.indexOf(prop) === -1) {
                newNode[prop] = this[prop];
            }
        }
        /** Copy inheritance props */
        newNode.inherit(this);
        return newNode;
    }
    eval(context) {
        if (!this.evaluated) {
            const node = this.clone();
            node.processNodes(n => n.eval(context));
            node.evaluated = true;
            return node;
        }
        return this;
    }
    inherit(node) {
        this.location = node.location;
        this.fileInfo = node.fileInfo;
        this.evaluated = node.evaluated;
        return this;
    }
    fround(value) {
        // add "epsilon" to ensure numbers like 1.000000005 (represented as 1.000000004999...) are properly rounded:
        return Number((value + 2e-16).toFixed(8));
    }
    valueOf() {
        return this.value;
    }
    /** Generate a .css file and .css.map */
    toCSS(context, out) {
        const value = this.value;
        const loc = this.location;
        if (Array.isArray(value)) {
            value.forEach(n => {
                if (n instanceof Node) {
                    n.toCSS(context, out);
                }
                else {
                    out.add(n.toString(), loc);
                }
            });
        }
        else {
            if (value instanceof Node) {
                value.toCSS(context, out);
            }
            else {
                out.add(value.toString(), loc);
            }
        }
    }
}
exports.Node = Node;
