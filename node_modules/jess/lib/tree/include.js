"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.include = exports.Include = void 0;
const isPlainObject_1 = __importDefault(require("lodash/isPlainObject"));
const node_1 = require("./node");
const declaration_1 = require("./declaration");
const ruleset_1 = require("./ruleset");
const root_1 = require("./root");
const call_1 = require("./call");
class Include extends node_1.Node {
    constructor(value, location) {
        if (node_1.isNodeMap(value)) {
            super(value, location);
        }
        else {
            super({ value }, location);
        }
    }
    eval(context) {
        let value = this.value;
        if (value instanceof call_1.Call) {
            value = value.eval(context);
        }
        /** Convert included objects into declaration sets */
        if (isPlainObject_1.default(value)) {
            const rules = [];
            for (let name in value) {
                if (Object.prototype.hasOwnProperty.call(value, name)) {
                    rules.push(new declaration_1.Declaration({
                        name,
                        value: context.cast((value[name])).eval(context)
                    }));
                }
            }
            return new ruleset_1.Ruleset(rules);
        }
        value = context.cast(value).eval(context);
        /**
         * Include Roots as plain Rulesets
         */
        if (value instanceof root_1.Root) {
            return new ruleset_1.Ruleset(value.value);
        }
        if (!value.allowRoot && !value.allowRuleRoot) {
            let message = '@include returned an invalid node.';
            if (value instanceof call_1.Call && this.value instanceof call_1.Call) {
                message += ` Unknown function "${value.name}"`;
            }
            throw { message };
        }
        return value;
    }
    toModule(context, out) {
        out.add('$J.include(');
        this.value.toModule(context, out);
        out.add(')');
    }
}
exports.Include = Include;
Include.prototype.type = 'Include';
const include = (value, location) => new Include(value, location);
exports.include = include;
