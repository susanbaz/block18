"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.expr = exports.Expression = void 0;
const node_1 = require("./node");
const anonymous_1 = require("./anonymous");
const nil_1 = require("./nil");
const list_1 = require("./list");
const ws_1 = require("./ws");
const combinate_1 = __importDefault(require("combinate"));
/**
 * A continuous collection of nodes
 */
class Expression extends node_1.Node {
    constructor(value, location) {
        if (node_1.isNodeMap(value)) {
            super(value, location);
            return;
        }
        const values = value.map(v => v.constructor === String ? new anonymous_1.Anonymous(v) : v);
        super({
            value: values
        }, location);
    }
    toArray() {
        return this.value.filter(node => node && !(node instanceof ws_1.WS));
    }
    eval(context) {
        const node = this.clone();
        /** Convert all values to Nodes */
        const cast = context.cast;
        node.value = node.value
            .map(n => cast(n).eval(context))
            .filter(n => n && !(n instanceof nil_1.Nil));
        let lists;
        node.value.forEach((n, i) => {
            if (n instanceof list_1.List) {
                if (!lists) {
                    lists = {};
                }
                lists[i] = n.value;
            }
        });
        if (lists) {
            /**
             * Create new expressions of the inherited type
             */
            const Clazz = Object.getPrototypeOf(this).constructor;
            const combinations = combinate_1.default(lists);
            const returnList = new list_1.List([]).inherit(this);
            combinations.forEach(combo => {
                const expr = [...node.value];
                for (let pos in combo) {
                    if (Object.prototype.hasOwnProperty.call(combo, pos)) {
                        expr[pos] = combo[pos];
                    }
                }
                returnList.value.push(new Clazz(expr));
            });
            if (returnList.value.length === 1) {
                return returnList.value[0];
            }
            return returnList;
        }
        if (node.value.length === 1) {
            return node.value[0];
        }
        return node;
    }
    toCSS(context, out) {
        const cast = context.cast;
        this.value.forEach(n => {
            const val = cast(n);
            val.toCSS(context, out);
        });
    }
    toModule(context, out) {
        const loc = this.location;
        out.add(`$J.expr([`, loc);
        const length = this.value.length - 1;
        this.value.forEach((n, i) => {
            n.toModule(context, out);
            if (i < length) {
                out.add(', ');
            }
        });
        out.add(`])`);
    }
}
exports.Expression = Expression;
Expression.prototype.type = 'Expression';
const expr = (...args) => new Expression(...args);
exports.expr = expr;
