"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CstVisitor = void 0;
const util_1 = require("./util");
const chevrotain_1 = require("chevrotain");
const tree_1 = require("../tree");
const js_import_1 = require("../tree/js-import");
class CstVisitor {
    constructor(parser) {
        this.parser = parser;
    }
    visit(ctx, Clazz) {
        if (!ctx) {
            return;
        }
        if (util_1.isToken(ctx)) {
            const tokens = this.parser.T;
            const { image, startOffset, startLine, startColumn, endOffset, endLine, endColumn } = ctx;
            const loc = [
                startOffset,
                startLine,
                startColumn,
                endOffset,
                endLine,
                endColumn
            ];
            if (image === '&') {
                return new tree_1.Ampersand;
            }
            if (chevrotain_1.tokenMatcher(ctx, tokens.Dimension) || chevrotain_1.tokenMatcher(ctx, tokens.Number)) {
                return new tree_1.Dimension(image, loc);
            }
            /** @todo - make more Node types eventually? */
            if (!Clazz) {
                if (chevrotain_1.tokenMatcher(ctx, tokens.Color)) {
                    Clazz = tree_1.Color;
                }
                else if (chevrotain_1.tokenMatcher(ctx, tokens.WS)) {
                    Clazz = tree_1.WS;
                }
                else {
                    Clazz = tree_1.Anonymous;
                }
            }
            return new Clazz(image, loc);
        }
        const visit = this[ctx.name];
        if (!visit) {
            throw { message: `CST '${ctx.name}' is not valid.` };
        }
        return visit.call(this, ctx);
    }
    visitArray(coll) {
        return coll.map(node => this.visit(node)).filter(node => node);
    }
    /** Start building AST */
    root({ children, location }) {
        const nodes = this.visitArray(children);
        return new tree_1.Root(nodes, util_1.getLocation(location));
    }
    rule({ children, location }) {
        let [pre, rule] = children;
        const ws = this.visit(pre);
        const node = this.visit(rule);
        return node;
    }
    atRule({ children, location }) {
        var _a;
        let name = children[0].image;
        const prelude = children[1];
        if (name === '@mixin') {
            name = prelude.children[1].image.replace(/\($/, '');
            const args = this.visit(prelude.children[4]);
            const value = this.visit(children[2]);
            return new tree_1.Mixin({ name: new tree_1.JsIdent(name), args, value });
        }
        else {
            const value = this.visit(prelude);
            if (((_a = prelude.children[1]) === null || _a === void 0 ? void 0 : _a.name) === 'atImportJs') {
                return new js_import_1.JsImport(value.value);
            }
            let rulesChild = children[2];
            let rules;
            if ('image' in rulesChild) {
                rules = undefined;
            }
            else {
                rules = this.visit(rulesChild);
            }
            return new tree_1.AtRule({ name, value, rules }, util_1.getLocation(location));
        }
    }
    mixinArgs({ children }) {
        const args = children
            .filter(child => child !== undefined && child.name === 'mixinArg')
            .map(arg => this.visit(arg));
        return new tree_1.List(args);
    }
    mixinArg({ children }) {
        const value = children[4];
        if (value) {
            const name = this.visit(children[0], tree_1.JsIdent);
            return new tree_1.JsKeyValue({ name, value: this.visit(value) });
        }
        return this.visit(children[0], tree_1.JsIdent);
    }
    atInclude({ children }) {
        return new tree_1.Include(this.visit(children[2]));
    }
    atLet({ children, location }) {
        return new tree_1.Let(this.visit(children[2]), util_1.getLocation(location));
    }
    atLetValue({ children }) {
        const name = children[0].children[0].image;
        return new tree_1.JsKeyValue({
            name: new tree_1.JsIdent(name),
            value: this.visit(children[1].children[0])
        });
    }
    jsCollection({ children }) {
        const nodes = this.visitArray(children[2].children);
        return new tree_1.JsCollection(nodes);
    }
    jsCollectionNode({ children }) {
        return this.visit(children[0]);
    }
    /** @note - for now, just collect as one string */
    jsExpression({ children, location }) {
        children.shift();
        const firstChild = children[0];
        let post;
        if (firstChild.name === 'jsBlock' && firstChild.children[3]) {
            post = firstChild.children.pop();
        }
        const value = util_1.collapseTokens(util_1.collectTokens(children));
        return new tree_1.JsExpr({ value: value.image, post: post === null || post === void 0 ? void 0 : post.image }, util_1.getLocation(location));
    }
    prelude({ children }) {
        /**
         * For now, just collapse the prelude to a single anonymous node
         */
        const tokens = [];
        util_1.collectTokens(children, tokens);
        return this.visit(util_1.collapseTokens(tokens));
    }
    customPrelude({ children }) {
        const tokens = [];
        util_1.collectTokens(children, tokens);
        return this.visit(util_1.collapseTokens(tokens));
    }
    customValue({ children }) {
        const value = util_1.collapseTokens(util_1.collectTokens(children));
        return new tree_1.Anonymous(value.image);
    }
    qualifiedRule({ children, location }) {
        const [selectorList, curlyBlock] = children;
        const sels = this.visit(selectorList);
        const value = this.visit(curlyBlock);
        return new tree_1.Rule({ sels, value }, util_1.getLocation(location));
    }
    selectorList({ children, location }) {
        const list = children.filter((val, i) => {
            return i % 2 === 0;
        }).map(node => this.visit(node));
        return new tree_1.List(list, util_1.getLocation(location));
    }
    complexSelector({ children, location }) {
        const [initial, ...combinators] = children;
        const compound = this.visit(initial);
        const combinator = util_1.flatten(this.visitArray(combinators));
        return new tree_1.Selector([...compound, ...combinator], util_1.getLocation(location));
    }
    compoundSelector({ children }) {
        return children.map(child => this.visit(child, tree_1.Element));
    }
    combinatorSelector({ children }) {
        /** Discard trailing WS */
        if (children.length === 1) {
            return [];
        }
        return [
            this.visit(children[0].children[1], tree_1.Combinator),
            ...this.visit(children[1])
        ];
    }
    pseudoSelector({ children }) {
        const selector = util_1.collapseTokens(util_1.collectTokens(children));
        return new tree_1.Element(selector.image);
    }
    attrSelector({ children }) {
        const selector = util_1.collapseTokens(util_1.collectTokens(children));
        return new tree_1.Element(selector.image);
    }
    curlyBlock({ children, location }) {
        const rules = this.visit(children[1]);
        return new tree_1.Ruleset(rules, util_1.getLocation(location));
    }
    rules({ children, location }) {
        return this.visitArray(children);
    }
    declaration({ children, location }) {
        const name = this.visit(children[0]);
        const value = this.visit(children[4]);
        const important = children[5] && this.visit(children[5].children[0]);
        return new tree_1.Declaration({ name, value, important }, util_1.getLocation(location));
    }
    /**
     * A property can contain interpolated statements,
     * so it's an expression
     */
    property({ children, location }) {
        const name = this.visitArray(children);
        return new tree_1.Expression(name, util_1.getLocation(location));
    }
    function({ children, location }) {
        const name = children[0].image.slice(0, -1);
        const value = this.visit(children[1]);
        return new tree_1.Call({ name, value }, util_1.getLocation(location));
    }
    block({ children, location }) {
        const char = children[0];
        if (char.image === '(') {
            return new tree_1.Paren(this.visit(children[1]), util_1.getLocation(location));
        }
        return new tree_1.Square(this.visit(children[1]), util_1.getLocation(location));
    }
    expression({ children, location }) {
        const value = this.visitArray(children);
        if (value[0] instanceof tree_1.WS) {
            value.shift();
        }
        if (value[value.length - 1] instanceof tree_1.WS) {
            value.pop();
        }
        if (value.length === 1) {
            return value[0];
        }
        return new tree_1.Expression(value, util_1.getLocation(location));
    }
    expressionList({ children, location }) {
        const list = children.filter((val, i) => {
            return i % 2 === 0;
        }).map(node => this.visit(node));
        if (list.length === 1) {
            return list[0];
        }
        return new tree_1.List(list, util_1.getLocation(location));
    }
}
exports.CstVisitor = CstVisitor;
