import { CstChild, CstNode, IToken } from '@jesscss/css-parser';
import type { JessParser } from '@jess/parser';
import { Anonymous, Call, Node, Root, Rule, List, Element, Ruleset, Declaration, Expression, Let, JsKeyValue, Selector, AtRule, JsCollection, JsExpr, Mixin, Include, Paren, Square } from '../tree';
import { JsImport } from '../tree/js-import';
export declare type BaseTokenType = Pick<IToken, 'image' | 'startLine' | 'startColumn' | 'startOffset' | 'endLine' | 'endColumn' | 'endOffset'>;
export declare class CstVisitor {
    [k: string]: any;
    parser: JessParser;
    constructor(parser: JessParser);
    visit(ctx: CstNode | BaseTokenType, Clazz?: any): any;
    visitArray(coll: CstChild[]): any[];
    /** Start building AST */
    root({ children, location }: CstNode): Root;
    rule({ children, location }: CstNode): Node;
    atRule({ children, location }: CstNode): AtRule | JsImport | Mixin;
    mixinArgs({ children }: CstNode): List<import("../tree/node").Primitive>;
    mixinArg({ children }: CstNode): any;
    atInclude({ children }: CstNode): Include;
    atLet({ children, location }: CstNode): Let;
    atLetValue({ children }: CstNode): JsKeyValue;
    jsCollection({ children }: CstNode): JsCollection;
    jsCollectionNode({ children }: CstNode): any;
    /** @note - for now, just collect as one string */
    jsExpression({ children, location }: CstNode): JsExpr;
    prelude({ children }: CstNode): any;
    customPrelude({ children }: CstNode): any;
    customValue({ children }: CstNode): Anonymous;
    qualifiedRule({ children, location }: CstNode): Rule;
    selectorList({ children, location }: CstNode): List<import("../tree/node").Primitive>;
    complexSelector({ children, location }: CstNode): Selector;
    compoundSelector({ children }: CstNode): any[];
    combinatorSelector({ children }: CstNode): any[];
    pseudoSelector({ children }: CstNode): Element;
    attrSelector({ children }: CstNode): Element;
    curlyBlock({ children, location }: CstNode): Ruleset;
    rules({ children, location }: CstNode): any[];
    declaration({ children, location }: CstNode): Declaration;
    /**
     * A property can contain interpolated statements,
     * so it's an expression
     */
    property({ children, location }: CstNode): Expression;
    function({ children, location }: CstNode): Call;
    block({ children, location }: CstNode): Paren | Square;
    expression({ children, location }: CstNode): any;
    expressionList({ children, location }: CstNode): any;
}
