"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
require("mocha");
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const testData = path.dirname(require.resolve('@less/test-data'));
const __1 = require("..");
const context_1 = require("../../context");
const output_1 = require("../../output");
let context;
let out;
const serialize = (str, expectStr) => __awaiter(void 0, void 0, void 0, function* () {
    expectStr = expectStr || str;
    const node = yield __1.parse(str);
    chai_1.expect(node.toString()).to.eq(expectStr);
});
describe('CST-to-AST', () => {
    beforeEach(() => {
        context = new context_1.Context;
        context.id = 'testing';
        context.depth = 2;
        out = new output_1.OutputCollector;
    });
    it(`rule #1`, () => __awaiter(void 0, void 0, void 0, function* () {
        const node = yield __1.parse(`.box> #foo.bar { a: b; }`);
        chai_1.expect(node.toString()).to.eq('.box > #foo.bar {\n  a: b;\n}\n');
    }));
    it(`rule #2`, () => __awaiter(void 0, void 0, void 0, function* () {
        const node = yield __1.parse(`@import url("something.css");`);
        chai_1.expect(node.toString()).to.eq(`@import url("something.css");\n`);
    }));
    it(`rule #3`, () => __awaiter(void 0, void 0, void 0, function* () {
        context.depth = 0;
        const node = yield __1.parse(`@import foo from 'foo.ts';`);
        node.value[0].toModule(context, out);
        chai_1.expect(out.toString()).to.eq('import foo from \'foo.ts\'');
    }));
    it(`rule #4`, () => __awaiter(void 0, void 0, void 0, function* () {
        context.depth = 0;
        const node = yield __1.parse(`@import foo, { bar } from 'foo.ts';`);
        node.value[0].toModule(context, out);
        chai_1.expect(out.toString()).to.eq('import foo, { bar } from \'foo.ts\'');
    }));
    it(`rule #5`, () => __awaiter(void 0, void 0, void 0, function* () {
        context.depth = 0;
        const node = yield __1.parse(`@import * as foo from 'foo.ts';`);
        node.value[0].toModule(context, out);
        chai_1.expect(out.toString()).to.eq('import * as foo from \'foo.ts\'');
    }));
    it(`rule #6`, () => __awaiter(void 0, void 0, void 0, function* () {
        context.depth = 0;
        const node = yield __1.parse(`@import { default as foo, bar } from 'foo.ts';`);
        node.value[0].toModule(context, out);
        chai_1.expect(out.toString()).to.eq('import { default as foo, bar } from \'foo.ts\'');
    }));
    it(`rule #7`, () => __awaiter(void 0, void 0, void 0, function* () {
        const node = yield __1.parse(`@let foo: 1;`);
        node.value[0].toModule(context, out);
        chai_1.expect(out.toString()).to.eq('let foo = $J.num({\n  value: 1,\n  unit: ""\n})');
    }));
    it(`rule #8`, () => __awaiter(void 0, void 0, void 0, function* () {
        const node = yield __1.parse(`@let foo { color: #FFF }`);
        node.value[0].toModule(context, out);
        chai_1.expect(out.toString()).to.eq('let foo = {\n  "color": $J.color("#FFF")\n}');
    }));
    it(`rule #9`, () => __awaiter(void 0, void 0, void 0, function* () {
        const node = yield __1.parse(`@let foo { color: #FFF; nested {} }`);
        node.value[0].toModule(context, out);
        chai_1.expect(out.toString()).to.eq('let foo = {\n  "color": $J.color("#FFF"),\n  "nested": {\n  }\n}');
    }));
    it(`rule #10`, () => __awaiter(void 0, void 0, void 0, function* () {
        const node = yield __1.parse(`@let foo { color: #FFF; nested { color: black } }`);
        node.value[0].toModule(context, out);
        chai_1.expect(out.toString()).to.eq('let foo = {\n  "color": $J.color("#FFF"),\n  "nested": {\n    "color": $J.anon("black")\n  }\n}');
    }));
    it(`rule #11`, () => __awaiter(void 0, void 0, void 0, function* () {
        const node = yield __1.parse(`@let foo: $value.foo`);
        node.value[0].toModule(context, out);
        chai_1.expect(out.toString()).to.eq('let foo = value.foo');
    }));
    it(`rule #12`, () => __awaiter(void 0, void 0, void 0, function* () {
        const node = yield __1.parse(`@let foo: $value.foo #FFF`);
        node.value[0].toModule(context, out);
        chai_1.expect(out.toString()).to.eq('let foo = $J.expr([value.foo, $J.ws(), $J.color("#FFF")])');
    }));
    it(`rule #13`, () => __awaiter(void 0, void 0, void 0, function* () {
        const node = yield __1.parse(`@let foo: $(value.foo && value.bar)`);
        node.value[0].toModule(context, out);
        chai_1.expect(out.toString()).to.eq('let foo = (value.foo && value.bar)');
    }));
    it(`rule #14`, () => __awaiter(void 0, void 0, void 0, function* () {
        const node = yield __1.parse(`@mixin foo {}`);
        node.value[0].toModule(context, out);
        chai_1.expect(out.toString()).to.eq('let foo = function() { return $J.ruleset(\n  (() => {\n    const $OUT = []\n    return $OUT\n  })()\n)}');
    }));
    it(`rule #15`, () => __awaiter(void 0, void 0, void 0, function* () {
        const node = yield __1.parse(`@mixin foo() {}`);
        node.value[0].toModule(context, out);
        chai_1.expect(out.toString()).to.eq('let foo = function() { return $J.ruleset(\n  (() => {\n    const $OUT = []\n    return $OUT\n  })()\n)}');
    }));
    it(`rule #16`, () => __awaiter(void 0, void 0, void 0, function* () {
        const node = yield __1.parse(`@mixin foo(bar, foo: 1px) {}`);
        node.value[0].toModule(context, out);
        chai_1.expect(out.toString()).to.eq('let foo = function(bar, foo = $J.num({\n  value: 1,\n  unit: "px"\n})) { return $J.ruleset(\n  (() => {\n    const $OUT = []\n    return $OUT\n  })()\n)}');
    }));
    it(`rule #17`, () => __awaiter(void 0, void 0, void 0, function* () {
        const node = yield __1.parse(`@include each($list, $mixin);`);
        node.value[0].toModule(context, out);
        chai_1.expect(out.toString()).to.eq('$J.include($J.call({\n  name: "each",\n  value: $J.list([\n    list,\n    mixin\n  ]),\n  ref: () => each,\n}))');
    }));
    it(`rule #18`, () => __awaiter(void 0, void 0, void 0, function* () {
        const node = yield __1.parse(`@include $each(list, mixin);`);
        node.value[0].toModule(context, out);
        chai_1.expect(out.toString()).to.eq('$J.include(each(list, mixin))');
    }));
    it(`rule #19`, () => __awaiter(void 0, void 0, void 0, function* () {
        const node = yield __1.parse(`@supports (property: value) {
        @media (max-size: 2px) {
          @supports (whatever: something) {
            .inner {
              property: value;
            }
          }
        }
      }`);
        chai_1.expect(node.toString()).to.eq('@supports (property: value) {\n  @media (max-size: 2px) {\n    @supports (whatever: something) {\n      .inner {\n        property: value;\n      }\n    }\n  }\n}\n');
    }));
    it(`rule #20`, () => __awaiter(void 0, void 0, void 0, function* () {
        let node = yield __1.parse(`&:hover {a:b}`);
        node.value[0].toModule(context, out);
        chai_1.expect(out.toString()).to.eq('$J.rule({\n  sels: $J.list([\n    $J.sel([$J.amp(), $J.el($J.anon(":hover"))])\n  ]),\n  value: $J.ruleset(\n    (() => {\n      const $OUT = []\n      $OUT.push($J.decl({\n        name: $J.expr([$J.anon("a")]),\n        value: $J.anon("b")\n      }))\n      return $OUT\n    })()\n  )},[1,1,0,1,13,12])');
        node = node.eval(context);
        chai_1.expect(node.value[0].toString()).to.eq(':hover {\n  a: b;\n}');
    }));
    it(`rule #21`, () => __awaiter(void 0, void 0, void 0, function* () {
        let node = yield __1.parse(`
      a, b {
        &:hover {
          background: blue;
        }
      }
      `);
        node = node.eval(context);
        chai_1.expect(node.toString()).to.eq('a:hover,\nb:hover {\n  background: blue;\n}\n');
    }));
    it(`rule #22`, () => __awaiter(void 0, void 0, void 0, function* () {
        let node = yield __1.parse(`
      a, b {
        + c {
          background: blue;
        }
      }
      `);
        node = node.eval(context);
        chai_1.expect(node.toString()).to.eq('a + c,\nb + c {\n  background: blue;\n}\n');
    }));
    it(`rule #23`, () => __awaiter(void 0, void 0, void 0, function* () {
        let node = yield __1.parse(`
      a, b, c {
        [foo]& {
          background: blue;
        }
      }
      `);
        node = node.eval(context);
        chai_1.expect(node.toString()).to.eq('[foo]a,\n[foo]b,\n[foo]c {\n  background: blue;\n}\n');
    }));
    it(`rule #24`, () => __awaiter(void 0, void 0, void 0, function* () {
        let node = yield __1.parse(`
      a, b {
        & + & {
          background: blue;
        }
      }
      `);
        node = node.eval(context);
        chai_1.expect(node.toString()).to.eq('a + a,\nb + a,\na + b,\nb + b {\n  background: blue;\n}\n');
    }));
    it(`rule #25`, () => __awaiter(void 0, void 0, void 0, function* () {
        let node = yield __1.parse(`
      @media all {
        a {
          b {
            color: rebeccapurple;
          }
        }
      }
      `);
        node = node.eval(context);
        chai_1.expect(node.toString()).to.eq('@media all {\n  a b {\n    color: rebeccapurple;\n  }\n}\n');
    }));
    it(`rule #26`, () => __awaiter(void 0, void 0, void 0, function* () {
        let node = yield __1.parse(`
      a {
        color: blue;
        @media all { 
          color: rebeccapurple;
        }
      }
      `);
        node = node.eval(context);
        chai_1.expect(node.toString()).to.eq('a {\n  color: blue;\n}\n@media all {\n  a {\n    color: rebeccapurple;\n  }\n}\n');
    }));
    it(`rule #27`, () => __awaiter(void 0, void 0, void 0, function* () {
        let node = yield __1.parse(`
      a {
        b {
          one: 1;
          &:hover {
            two: 2;
          }
        }
        c {
          three: 3;
          d {
            four: 4;
          }
          five: 5;
        }
      }
      `);
        node = node.eval(context);
        chai_1.expect(node.toString()).to.eq('a b {\n  one: 1;\n}\na b:hover {\n  two: 2;\n}\na c {\n  three: 3;\n  five: 5;\n}\na c d {\n  four: 4;\n}\n');
    }));
    it(`rule #28`, () => __awaiter(void 0, void 0, void 0, function* () {
        let node = yield __1.parse(`& { .box { a: b; } }`);
        node = node.eval(context);
        chai_1.expect(node.toString()).to.eq('.box {\n  a: b;\n}\n');
    }));
    it(`rule #29`, () => __awaiter(void 0, void 0, void 0, function* () {
        let node = yield __1.parse(`&, & { .box { a: b; } }`);
        node = node.eval(context);
        chai_1.expect(node.toString()).to.eq('.box,\n.box {\n  a: b;\n}\n');
    }));
});
/**
 * Jess doesn't output comments, so
 * this is a list of Less CSS output w/o comments
 * and with valid CSS.
 */
const validCSS = [
    "css/_main/calc.css",
    "css/_main/charsets.css",
    "css/_main/colors.css",
    "css/_main/colors2.css",
    "css/_main/css-grid.css",
    "css/_main/css-guards.css",
    "css/_main/empty.css",
    "css/_main/extend-chaining.css",
    "css/_main/extend-clearfix.css",
    "css/_main/extend-exact.css",
    "css/_main/extend-media.css",
    "css/_main/extend-nest.css",
    "css/_main/extend-selector.css",
    "css/_main/extend.css",
    "css/_main/extract-and-length.css",
    "css/_main/functions-each.css",
    "css/_main/ie-filters.css",
    "css/_main/import-module.css",
    "css/_main/import-once.css",
    "css/_main/import-remote.css",
    "css/_main/javascript.css",
    "css/_main/lazy-eval.css",
    "css/_main/merge.css",
    "css/_main/mixin-noparens.css",
    "css/_main/mixins-closure.css",
    "css/_main/mixins-guards-default-func.css",
    "css/_main/mixins-important.css",
    "css/_main/mixins-named-args.css",
    "css/_main/mixins-nested.css",
    "css/_main/mixins-pattern.css",
    "css/_main/mixins.css",
    "css/_main/no-output.css",
    "css/_main/operations.css",
    "css/_main/parse-interpolation.css",
    "css/_main/permissive-parse.css",
    "css/_main/plugin-preeval.css",
    "css/_main/property-accessors.css",
    "css/_main/rulesets.css",
    "css/_main/scope.css",
    "css/_main/strings.css",
    "css/_main/urls.css",
    "css/_main/variables-in-at-rules.css",
    "css/_main/variables.css"
];
describe('can turn CSS into an AST', () => {
    validCSS.forEach(file => {
        it(`${file}`, () => __awaiter(void 0, void 0, void 0, function* () {
            const result = fs.readFileSync(path.join(testData, file)).toString();
            yield serialize(result);
        }));
    });
});
