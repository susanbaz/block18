import { Node } from './tree/node';
export declare type ContextOptions = {
    module?: boolean;
    dynamic?: boolean;
    [k: string]: string | number | boolean;
};
export declare const generateId: (length?: number) => string;
export declare class Context {
    opts: ContextOptions;
    originalOpts: ContextOptions;
    /**
     * The file (eval) context should have the same ID at compile-time
     * as run-time, so this ID will be set in `toModule()` output
     */
    id: string;
    varCounter: number;
    classMap: {
        [k: string]: string;
    };
    frames: Node[];
    /** Keeps track of the indention level */
    indent: number;
    /**
     * Keys of @let variables --
     * We need this b/c we need to generate code
     * for over-riding in the exported function.
     */
    exports: Set<string>;
    depth: number;
    rootRules: Node[];
    /** currently generating a runtime module or not */
    isRuntime: boolean;
    /** In a custom declaration's value */
    inCustom: boolean;
    /** In a selector */
    inSelector: boolean;
    constructor(opts?: ContextOptions);
    get pre(): string;
    /** Hash a CSS class name or not depending on the `module` setting */
    hashClass(name: string): string;
    getVar(): string;
    /**
     * Casts a primitive value to a Jess node
     * (if not already). This is for CSS output.
     *
     * @example
     * cast(area(5))
     */
    cast(value: any): Node;
}
