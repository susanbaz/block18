"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CssParser = void 0;
const chevrotain_1 = require("chevrotain");
const root_1 = __importDefault(require("./productions/root"));
const atRules_1 = __importDefault(require("./productions/atRules"));
const blocks_1 = __importDefault(require("./productions/blocks"));
const selectors_1 = __importDefault(require("./productions/selectors"));
const declarations_1 = __importDefault(require("./productions/declarations"));
const values_1 = __importDefault(require("./productions/values"));
class CssParser extends chevrotain_1.EmbeddedActionsParser {
    constructor(tokens, T, config = {
        maxLookahead: 1,
        recoveryEnabled: true
    }) {
        super(tokens, config);
        const $ = this;
        $.T = T;
        root_1.default.call($, $);
        atRules_1.default.call($, $);
        blocks_1.default.call($, $);
        selectors_1.default.call($, $);
        declarations_1.default.call($, $);
        values_1.default.call($, $);
        /** If this is extended, don't perform self-analysis twice */
        if ($.constructor === CssParser) {
            $.performSelfAnalysis();
        }
    }
    /** Capture location information for CST nodes */
    CAPTURE(func) {
        if (!this.RECORDING_PHASE) {
            const startIndex = this.currIdx + 1;
            const result = func();
            const endIndex = this.currIdx;
            if (result && result.name) {
                const startToken = this.input[startIndex];
                const endToken = this.input[endIndex];
                if (startToken && endToken) {
                    const { startOffset, startColumn, startLine } = startToken;
                    const { endOffset, endColumn, endLine } = endToken;
                    result.location = {
                        startOffset, startColumn, startLine,
                        endOffset, endColumn, endLine
                    };
                }
            }
            return result;
        }
        return func();
    }
    RULE(name, impl, config) {
        return super.RULE(name, (...args) => this.CAPTURE(() => impl(...args)), config);
    }
    OVERRIDE_RULE(name, impl, config) {
        return super.OVERRIDE_RULE(name, (...args) => this.CAPTURE(() => impl(...args)), config);
    }
}
exports.CssParser = CssParser;
